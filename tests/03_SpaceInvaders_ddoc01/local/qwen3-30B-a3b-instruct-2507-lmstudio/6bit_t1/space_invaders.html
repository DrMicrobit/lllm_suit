<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Invaders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #071029;
            font-family: sans-serif;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            max-width: 1200px;
            height: auto;
            border: 2px solid #333;
            background-color: #071029;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Game configuration
        const CONFIG = {
            CANVAS_W: 800,
            CANVAS_H: 600,
            HUD_HEIGHT: 48,
            PLAYER_Y: 540,
            BUNKER_Y: 460,
            INVADER_WIDTH: 48,
            INVADER_HEIGHT: 42,
            INVADER_H_SPACING: 8,
            INVADER_V_SPACING: 12,
            BUNKER_BLOCK_WIDTH: 14,
            BUNKER_BLOCK_HEIGHT: 12,
            BUNKER_BLOCK_MARGIN: 2,
            BULLET_WIDTH: 4,
            BULLET_HEIGHT: 12,
            PLAYER_SPEED: 260,
            PLAYER_BULLET_SPEED: 420,
            INVADER_SPEED_BASE: 22,
            INVADER_DROP_AMOUNT: 18,
            INVADER_ANIMATION_INTERVAL: 0.45,
            INVADER_SHOOT_INTERVAL_BASE: 1.1,
            INVADER_BULLET_SPEED: 190,
            UFO_SPEED: 140,
            EXPLOSION_DURATION: 0.3,
            MAX_PLAYER_BULLETS: 1,
            MAX_INVADER_BULLETS: 6,
            MAX_EXPLOSIONS: 30,
            STAR_COUNT: 100,
            STAR_SPEED: 0.5,
            SCORE_ROWS: [30, 20, 20, 10, 10],
            INITIAL_LIVES: 3,
            LOCAL_STORAGE_KEY: 'space_invaders_highscore_v1'
        };

        // Game state
        let gameState = {
            state: 'TITLE', // TITLE, PLAYING, PAUSED, GAMEOVER
            score: 0,
            highScore: parseInt(localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY) || 0),
            lives: CONFIG.INITIAL_LIVES,
            level: 1,
            lastTime: performance.now(),
            invaderSpeed: CONFIG.INVADER_SPEED_BASE,
            invaderAnimationTimer: 0,
            invaderShootTimer: 0,
            ufoSpawnTimer: 0,
            ufoActive: false,
            ufoX: 0,
            ufoY: 0,
            ufoDirection: 1,
            showHitboxes: false,
            sfxVolume: 1.0
        };

        // DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas dimensions
        canvas.width = CONFIG.CANVAS_W;
        canvas.height = CONFIG.CANVAS_H;

        // Starfield
        const stars = [];
        for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * CONFIG.CANVAS_W,
                y: Math.random() * CONFIG.CANVAS_H,
                speed: Math.random() * CONFIG.STAR_SPEED + 0.1,
                size: Math.random() * 2 + 1
            });
        }

        // Input state
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            KeyA: false,
            KeyD: false,
            KeyW: false,
            KeyK: false,
            KeyP: false,
            Escape: false
        };

        // Audio context
        let audioContext = null;
        let sfx = {};

        // Initialize audio context
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create SFX generators
            sfx.start = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(440, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                osc.type = 'square';
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            };

            sfx.shot = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.05);
                osc.type = 'square';
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.05);
            };

            sfx.invaderShot = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(330, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.1);
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.08, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            };

            sfx.invaderDeath = () => {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const noise = audioContext.createBufferSource();
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);

                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }

                noise.buffer = noiseBuffer;
                noise.connect(gain);
                gain.connect(audioContext.destination);

                osc1.connect(gain);
                osc2.connect(gain);

                osc1.frequency.setValueAtTime(220, audioContext.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1);
                osc1.type = 'square';

                osc2.frequency.setValueAtTime(440, audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.1);
                osc2.type = 'triangle';

                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                osc1.start(audioContext.currentTime);
                osc2.start(audioContext.currentTime);
                noise.start(audioContext.currentTime);

                osc1.stop(audioContext.currentTime + 0.1);
                osc2.stop(audioContext.currentTime + 0.1);
                noise.stop(audioContext.currentTime + 0.1);
            };

            sfx.playerDeath = () => {
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(audioContext.destination);

                osc1.frequency.setValueAtTime(110, audioContext.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.05);
                osc1.type = 'sine';

                osc2.frequency.setValueAtTime(440, audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.05);
                osc2.type = 'sine';

                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                osc1.start(audioContext.currentTime);
                osc2.start(audioContext.currentTime);

                osc1.stop(audioContext.currentTime + 0.05);
                osc2.stop(audioContext.currentTime + 0.05);
            };

            sfx.blockHit = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(660, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.05);
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.08, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.05);
            };

            sfx.ufo = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(220, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.2);
                osc.type = 'square';
                gain.gain.setValueAtTime(0.05, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.2);
            };

            sfx.gameOver = () => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.5);
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.5);
            };
        }

        // Entity constructors
        function createPlayer(x, y) {
            return {
                x,
                y,
                width: 48,
                height: 20,
                color: '#FFFFFF',
                accentColor: '#6B9CFF',
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // Ship body
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(24, -20);
                    ctx.lineTo(48, 0);
                    ctx.lineTo(24, 10);
                    ctx.closePath();
                    ctx.fill();

                    // Ship accent
                    ctx.fillStyle = this.accentColor;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(24, -15);
                    ctx.lineTo(48, 0);
                    ctx.closePath();
                    ctx.fill();

                    // Ship outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                },
                getHitbox() {
                    return {
                        x: this.x - this.width / 2,
                        y: this.y - this.height / 2,
                        width: this.width,
                        height: this.height
                    };
                }
            };
        }

        function createInvader(x, y, row) {
            const colors = ['#FF6B6B', '#FFB86B', '#FFD56B', '#6BFFB8', '#6B9CFF'];
            const color = colors[row];

            return {
                x,
                y,
                width: CONFIG.INVADER_WIDTH,
                height: CONFIG.INVADER_HEIGHT,
                color,
                row,
                frame: 0,
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // Invader body
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(12, 18);
                    ctx.lineTo(24, 18);
                    ctx.lineTo(36, 18);
                    ctx.lineTo(48, 0);
                    ctx.lineTo(36, -12);
                    ctx.lineTo(24, -12);
                    ctx.lineTo(12, -12);
                    ctx.closePath();
                    ctx.fill();

                    // Invader eyes
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(12, -6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(36, -6, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Invader outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                },
                getHitbox() {
                    return {
                        x: this.x - this.width / 2,
                        y: this.y - this.height / 2,
                        width: this.width - 6,
                        height: this.height - 6
                    };
                }
            };
        }

        function createBullet(x, y, speed, isPlayer = false) {
            return {
                x,
                y,
                width: CONFIG.BULLET_WIDTH,
                height: CONFIG.BULLET_HEIGHT,
                speed,
                isPlayer,
                draw() {
                    ctx.fillStyle = isPlayer ? '#FFFFFF' : '#FF6B6B';
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                },
                update(dt) {
                    this.y += this.speed * dt;
                },
                getHitbox() {
                    return {
                        x: this.x - this.width / 2,
                        y: this.y - this.height / 2,
                        width: this.width,
                        height: this.height
                    };
                }
            };
        }

        function createBunker(x, y) {
            const blocks = [];
            const width = CONFIG.BUNKER_BLOCK_WIDTH;
            const height = CONFIG.BUNKER_BLOCK_HEIGHT;
            const margin = CONFIG.BUNKER_BLOCK_MARGIN;

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 5; col++) {
                    const blockX = x + (col * (width + margin));
                    const blockY = y + (row * (height + margin));
                    blocks.push({
                        x: blockX,
                        y: blockY,
                        width,
                        height,
                        destroyed: false,
                        draw() {
                            if (this.destroyed) return;

                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Block body
                            ctx.fillStyle = '#2E8B57';
                            ctx.beginPath();
                            ctx.roundRect(0, 0, width, height, 3);
                            ctx.fill();

                            // Highlight
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.beginPath();
                            ctx.roundRect(0, 0, width * 0.7, height * 0.5, 3);
                            ctx.fill();

                            // Shadow
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            ctx.beginPath();
                            ctx.roundRect(0, 0, width * 0.8, height * 0.4, 3);
                            ctx.fill();

                            ctx.restore();
                        }
                    });
                }
            }

            return {
                x,
                y,
                width: 5 * (width + margin) - margin,
                height: 4 * (height + margin) - margin,
                blocks,
                draw() {
                    this.blocks.forEach(block => block.draw());
                },
                hit(x, y) {
                    for (const block of this.blocks) {
                        if (!block.destroyed &&
                            x >= block.x && x <= block.x + block.width &&
                            y >= block.y && y <= block.y + block.height) {
                            block.destroyed = true;
                            sfx.blockHit();
                            return true;
                        }
                    }
                    return false;
                }
            };
        }

        function createExplosion(x, y) {
            return {
                x,
                y,
                frame: 0,
                maxFrames: 12,
                duration: CONFIG.EXPLOSION_DURATION,
                startTime: performance.now(),
                color: '#FF6B6B',
                size: 8,
                draw() {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    const progress = Math.min(elapsed / this.duration, 1);

                    if (progress < 1) {
                        const alpha = 1 - progress;
                        const scale = 1 + progress * 0.5;

                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.globalAlpha = alpha;

                        // Explosion particles
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const length = 8 + progress * 12;
                            const x = Math.cos(angle) * length;
                            const y = Math.sin(angle) * length;

                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.arc(x, y, this.size * (1 - progress), 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Center glow
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.5 * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }
                },
                update() {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    return elapsed >= this.duration;
                }
            };
        }

        function createUfo() {
            return {
                x: -50,
                y: 50,
                width: 40,
                height: 20,
                speed: CONFIG.UFO_SPEED,
                direction: 1,
                frame: 0,
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // UFO body
                    ctx.fillStyle = '#FF6B6B';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, -10);
                    ctx.lineTo(40, 0);
                    ctx.lineTo(20, 10);
                    ctx.closePath();
                    ctx.fill();

                    // UFO details
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(10, -5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(30, -5, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // UFO outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                },
                update(dt) {
                    this.x += this.speed * dt * this.direction;
                    this.frame += dt;

                    // Wrap around screen
                    if (this.x > CONFIG.CANVAS_W + 50) {
                        this.x = -50;
                        this.y = Math.random() * 100 + 50;
                    }

                    if (this.x < -50) {
                        this.x = CONFIG.CANVAS_W + 50;
                        this.y = Math.random() * 100 + 50;
                    }
                },
                getHitbox() {
                    return {
                        x: this.x - this.width / 2,
                        y: this.y - this.height / 2,
                        width: this.width,
                        height: this.height
                    };
                }
            };
        }

        // Game manager
        let player = null;
        let invaders = [];
        let playerBullets = [];
        let invaderBullets = [];
        let explosions = [];
        let ufo = null;
        let bunkers = [];

        function initGame() {
            // Reset game state
            gameState.score = 0;
            gameState.lives = CONFIG.INITIAL_LIVES;
            gameState.level = 1;
            gameState.invaderSpeed = CONFIG.INVADER_SPEED_BASE;
            gameState.invaderAnimationTimer = 0;
            gameState.invaderShootTimer = 0;
            gameState.ufoSpawnTimer = 0;
            gameState.ufoActive = false;
            gameState.showHitboxes = false;

            // Create player
            player = createPlayer(CONFIG.CANVAS_W / 2, CONFIG.PLAYER_Y);

            // Create invaders
            invaders = [];
            const invaderWidth = CONFIG.INVADER_WIDTH;
            const invaderHeight = CONFIG.INVADER_HEIGHT;
            const spacingX = CONFIG.INVADER_H_SPACING;
            const spacingY = CONFIG.INVADER_V_SPACING;
            const startX = (CONFIG.CANVAS_W - (CONFIG.INVADER_COLS * (invaderWidth + spacingX) - spacingX)) / 2;
            const startY = 80;

            for (let row = 0; row < CONFIG.INVADER_ROWS; row++) {
                for (let col = 0; col < CONFIG.INVADER_COLS; col++) {
                    const x = startX + col * (invaderWidth + spacingX);
                    const y = startY + row * (invaderHeight + spacingY);
                    invaders.push(createInvader(x, y, row));
                }
            }

            // Create bunkers
            bunkers = [];
            const bunkerWidth = 5 * (CONFIG.BUNKER_BLOCK_WIDTH + CONFIG.BUNKER_BLOCK_MARGIN) - CONFIG.BUNKER_BLOCK_MARGIN;
            const bunkerHeight = 4 * (CONFIG.BUNKER_BLOCK_HEIGHT + CONFIG.BUNKER_BLOCK_MARGIN) - CONFIG.BUNKER_BLOCK_MARGIN;
            const bunkerSpacing = (CONFIG.CANVAS_W - 4 * bunkerWidth - 3 * 50) / 5;
            const startXBunker = 50;

            for (let i = 0; i < 4; i++) {
                const x = startXBunker + i * (bunkerWidth + bunkerSpacing);
                const y = CONFIG.BUNKER_Y;
                bunkers.push(createBunker(x, y));
            }

            // Clear bullets
            playerBullets = [];
            invaderBullets = [];
            explosions = [];
            ufo = null;

            // Start audio
            if (!audioContext) initAudio();
        }

        function levelUp() {
            // Increase level
            gameState.level++;

            // Increase invader speed
            gameState.invaderSpeed *= 1.12;

            // Decrease animation interval
            CONFIG.INVADER_ANIMATION_INTERVAL *= 0.92;

            // Reset invader positions
            const invaderWidth = CONFIG.INVADER_WIDTH;
            const invaderHeight = CONFIG.INVADER_HEIGHT;
            const spacingX = CONFIG.INVADER_H_SPACING;
            const spacingY = CONFIG.INVADER_V_SPACING;
            const startX = (CONFIG.CANVAS_W - (CONFIG.INVADER_COLS * (invaderWidth + spacingX) - spacingX)) / 2;
            const startY = 80;

            for (let row = 0; row < CONFIG.INVADER_ROWS; row++) {
                for (let col = 0; col < CONFIG.INVADER_COLS; col++) {
                    const x = startX + col * (invaderWidth + spacingX);
                    const y = startY + row * (invaderHeight + spacingY);
                    invaders[row * CONFIG.INVADER_COLS + col].x = x;
                    invaders[row * CONFIG.INVADER_COLS + col].y = y;
                }
            }

            // Reset invader animation timer
            gameState.invaderAnimationTimer = 0;

            // Reset UFO
            ufo = null;
            gameState.ufoActive = false;
            gameState.ufoSpawnTimer = 0;

            // Reset player position
            player.x = CONFIG.CANVAS_W / 2;
            player.y = CONFIG.PLAYER_Y;

            // Reset bunkers
            for (const bunker of bunkers) {
                for (const block of bunker.blocks) {
                    block.destroyed = false;
                }
            }
        }

        function handleInput(dt) {
            // Check keyboard input
            const moveLeft = keys.ArrowLeft || keys.KeyA;
            const moveRight = keys.ArrowRight || keys.KeyD;
            const shoot = keys.Space || keys.KeyW || keys.KeyK;
            const pause = keys.KeyP || keys.Escape;

            // Player movement
            if (moveLeft) {
                player.x -= CONFIG.PLAYER_SPEED * dt;
                if (player.x < 24) player.x = 24;
            }
            if (moveRight) {
                player.x += CONFIG.PLAYER_SPEED * dt;
                if (player.x > CONFIG.CANVAS_W - 24) player.x = CONFIG.CANVAS_W - 24;
            }

            // Player shooting
            if (shoot && playerBullets.length < CONFIG.MAX_PLAYER_BULLETS) {
                const bullet = createBullet(player.x, player.y - 20, CONFIG.PLAYER_BULLET_SPEED, true);
                playerBullets.push(bullet);
                sfx.shot();
            }

            // Pause toggle
            if (pause && gameState.state === 'PLAYING') {
                gameState.state = 'PAUSED';
            } else if (pause && gameState.state === 'PAUSED') {
                gameState.state = 'PLAYING';
            }

            // Debug: show/hide hitboxes
            if (keys.KeyH) {
                gameState.showHitboxes = !gameState.showHitboxes;
            }

            // Reset keys after processing
            keys.Space = false;
            keys.KeyW = false;
            keys.KeyK = false;
            keys.KeyP = false;
            keys.Escape = false;
        }

        function updateInvaders(dt) {
            // Update invader animation timer
            gameState.invaderAnimationTimer += dt;
            if (gameState.invaderAnimationTimer >= CONFIG.INVADER_ANIMATION_INTERVAL) {
                gameState.invaderAnimationTimer = 0;
                // Toggle invader frame (simple animation)
                for (const invader of invaders) {
                    invader.frame = 1 - invader.frame;
                }
            }

            // Check if any invader is near player
            for (const invader of invaders) {
                if (invader.y >= player.y - 40) {
                    // Player hit
                    playerHit();
                    return;
                }
            }

            // Check if any invader is at the edge
            let leftmost = Infinity;
            let rightmost = -Infinity;
            let anyAlive = false;

            for (const invader of invaders) {
                if (!invader.destroyed) {
                    anyAlive = true;
                    leftmost = Math.min(leftmost, invader.x - invader.width / 2);
                    rightmost = Math.max(rightmost, invader.x + invader.width / 2);
                }
            }

            if (!anyAlive) {
                // All invaders destroyed
                levelUp();
                return;
            }

            // Check if formation hits edge
            const edgeMargin = 16;
            if (leftmost <= edgeMargin || rightmost >= CONFIG.CANVAS_W - edgeMargin) {
                // Move down and flip direction
                for (const invader of invaders) {
                    if (!invader.destroyed) {
                        invader.y += CONFIG.INVADER_DROP_AMOUNT;
                    }
                }

                // Flip direction
                const speed = gameState.invaderSpeed;
                gameState.invaderSpeed = -speed;
            }

            // Move formation
            const speed = gameState.invaderSpeed;
            for (const invader of invaders) {
                if (!invader.destroyed) {
                    invader.x += speed * dt;
                }
            }

            // Invader shooting
            gameState.invaderShootTimer += dt;
            const aliveInvaders = invaders.filter(invader => !invader.destroyed);
            const aliveCount = aliveInvaders.length;
            const totalInvaders = CONFIG.INVADER_ROWS * CONFIG.INVADER_COLS;

            // Calculate shooting frequency based on level and number of invaders
            const shootingFrequency = CONFIG.INVADER_SHOOT_INTERVAL_BASE * (1 + 0.5 * (1 - aliveCount / totalInvaders));

            if (gameState.invaderShootTimer >= shootingFrequency) {
                gameState.invaderShootTimer = 0;

                // Find bottom-most alive invaders in each column
                const bottomInvaders = {};
                for (const invader of aliveInvaders) {
                    const col = Math.floor((invader.x - (CONFIG.CANVAS_W - (CONFIG.INVADER_COLS * (CONFIG.INVADER_WIDTH + CONFIG.INVADER_H_SPACING) - CONFIG.INVADER_H_SPACING)) / 2) / (CONFIG.INVADER_WIDTH + CONFIG.INVADER_H_SPACING));
                    if (!bottomInvaders[col] || invader.y > bottomInvaders[col].y) {
                        bottomInvaders[col] = invader;
                    }
                }

                // Randomly choose invaders to shoot
                for (const col in bottomInvaders) {
                    if (Math.random() < 0.3) { // 30% chance to shoot
                        const invader = bottomInvaders[col];
                        const bullet = createBullet(invader.x, invader.y + 20, CONFIG.INVADER_BULLET_SPEED, false);
                        invaderBullets.push(bullet);
                        sfx.invaderShot();
                    }
                }
            }

            // UFO spawning
            gameState.ufoSpawnTimer += dt;
            if (gameState.ufoActive === false && gameState.ufoSpawnTimer >= 5.0) {
                gameState.ufoSpawnTimer = 0;
                gameState.ufoActive = true;
                ufo = createUfo();
            }

            // Update UFO
            if (ufo && gameState.ufoActive) {
                ufo.update(dt);
            }
        }

        function updateBullets(dt) {
            // Update player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.update(dt);

                // Remove bullets that are off screen
                if (bullet.y < 0) {
                    playerBullets.splice(i, 1);
                }
            }

            // Update invader bullets
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                const bullet = invaderBullets[i];
                bullet.update(dt);

                // Remove bullets that are off screen
                if (bullet.y > CONFIG.CANVAS_H) {
                    invaderBullets.splice(i, 1);
                }
            }

            // Check for collisions
            // Player bullets vs invaders
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                for (let j = 0; j < invaders.length; j++) {
                    const invader = invaders[j];
                    if (!invader.destroyed && checkCollision(bullet, invader)) {
                        // Remove invader
                        invader.destroyed = true;

                        // Add score
                        gameState.score += CONFIG.SCORE_ROWS[invader.row];

                        // Play SFX
                        sfx.invaderDeath();

                        // Create explosion
                        const explosion = createExplosion(invader.x, invader.y);
                        explosions.push(explosion);

                        // Remove bullet
                        playerBullets.splice(i, 1);

                        // Check if all invaders are destroyed
                        const aliveCount = invaders.filter(invader => !invader.destroyed).length;
                        if (aliveCount === 0) {
                            levelUp();
                        }

                        break;
                    }
                }
            }

            // Invader bullets vs player
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                const bullet = invaderBullets[i];
                if (checkCollision(bullet, player)) {
                    // Player hit
                    playerHit();

                    // Remove bullet
                    invaderBullets.splice(i, 1);
                }
            }

            // Player bullets vs invader bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet1 = playerBullets[i];
                for (let j = invaderBullets.length - 1; j >= 0; j--) {
                    const bullet2 = invaderBullets[j];
                    if (checkCollision(bullet1, bullet2)) {
                        // Remove both bullets
                        playerBullets.splice(i, 1);
                        invaderBullets.splice(j, 1);
                        break;
                    }
                }
            }

            // UFO vs player
            if (ufo && gameState.ufoActive) {
                if (checkCollision(ufo, player)) {
                    // Player hit by UFO
                    playerHit();
                    gameState.ufoActive = false;
                    ufo = null;
                }
            }

            // UFO vs player bullets
            if (ufo && gameState.ufoActive) {
                for (let i = playerBullets.length - 1; i >= 0; i--) {
                    const bullet = playerBullets[i];
                    if (checkCollision(bullet, ufo)) {
                        // Destroy UFO
                        gameState.ufoActive = false;
                        ufo = null;

                        // Add score
                        gameState.score += 100;

                        // Play SFX
                        sfx.invaderDeath();

                        // Create explosion
                        const explosion = createExplosion(ufo.x, ufo.y);
                        explosions.push(explosion);

                        // Remove bullet
                        playerBullets.splice(i, 1);

                        break;
                    }
                }
            }
        }

        function playerHit() {
            // Play SFX
            sfx.playerDeath();

            // Decrease lives
            gameState.lives--;

            // Reset player position
            player.x = CONFIG.CANVAS_W / 2;
            player.y = CONFIG.PLAYER_Y;

            // Clear bullets
            playerBullets = [];

            // Check if game over
            if (gameState.lives <= 0) {
                // Game over
                gameState.state = 'GAMEOVER';
                sfx.gameOver();

                // Update high score
                if (gameState.score > gameState.highScore) {
                    gameState.highScore = gameState.score;
                    localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, gameState.highScore);
                }
            } else {
                // Respawn player after delay
                setTimeout(() => {
                    // Player is invulnerable for a short time
                    // This is handled by the game loop
                }, 800);
            }
        }

        function updateExplosions() {
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                if (explosion.update()) {
                    explosions.splice(i, 1);
                }
            }
        }

        function updateStarfield() {
            // Update star positions
            for (const star of stars) {
                star.y += star.speed;
                if (star.y > CONFIG.CANVAS_H) {
                    star.y = 0;
                    star.x = Math.random() * CONFIG.CANVAS_W;
                }
            }
        }

        function checkCollision(obj1, obj2) {
            const hitbox1 = obj1.getHitbox();
            const hitbox2 = obj2.getHitbox();

            return hitbox1.x < hitbox2.x + hitbox2.width &&
                hitbox1.x + hitbox1.width > hitbox2.x &&
                hitbox1.y < hitbox2.y + hitbox2.height &&
                hitbox1.y + hitbox1.height > hitbox2.y;
        }

        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

            // Draw background
            ctx.fillStyle = '#071029';
            ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

            // Draw starfield
            ctx.fillStyle = '#FFFFFF';
            for (const star of stars) {
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }

            // Draw HUD background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.HUD_HEIGHT);

            // Draw HUD text
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${gameState.score}`, 20, 30);

            ctx.textAlign = 'center';
            ctx.fillText(`HIGH SCORE: ${gameState.highScore}`, CONFIG.CANVAS_W / 2, 30);

            ctx.textAlign = 'right';
            ctx.fillText(`LIVES: ${'â™¥'.repeat(gameState.lives)} LEVEL: ${gameState.level}`, CONFIG.CANVAS_W - 20, 30);

            // Draw game entities
            // Draw invaders
            for (const invader of invaders) {
                if (!invader.destroyed) {
                    invader.draw();
                }
            }

            // Draw invader bullets
            for (const bullet of invaderBullets) {
                bullet.draw();
            }

            // Draw bunkers
            for (const bunker of bunkers) {
                bunker.draw();
            }

            // Draw player bullets
            for (const bullet of playerBullets) {
                bullet.draw();
            }

            // Draw player
            player.draw();

            // Draw explosions
            for (const explosion of explosions) {
                explosion.draw();
            }

            // Draw UFO
            if (ufo && gameState.ufoActive) {
                ufo.draw();
            }

            // Draw hitboxes (debug)
            if (gameState.showHitboxes) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;

                // Draw player hitbox
                const playerHitbox = player.getHitbox();
                ctx.strokeRect(playerHitbox.x, playerHitbox.y, playerHitbox.width, playerHitbox.height);

                // Draw invader hitboxes
                for (const invader of invaders) {
                    if (!invader.destroyed) {
                        const hitbox = invader.getHitbox();
                        ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
                    }
                }

                // Draw bullet hitboxes
                for (const bullet of playerBullets) {
                    const hitbox = bullet.getHitbox();
                    ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
                }

                for (const bullet of invaderBullets) {
                    const hitbox = bullet.getHitbox();
                    ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
                }

                // Draw UFO hitbox
                if (ufo && gameState.ufoActive) {
                    const hitbox = ufo.getHitbox();
                    ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
                }
            }

            // Draw overlays
            if (gameState.state === 'TITLE') {
                // Draw title screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('SPACE INVADERS', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 - 50);

                ctx.font = '24px sans-serif';
                ctx.fillText('Use Arrow Keys or A/D to move', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2);
                ctx.fillText('Press Space or W/K to shoot', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 30);
                ctx.fillText('Press P or Escape to pause', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 60);
                ctx.fillText('Press H to toggle hitboxes', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 90);

                ctx.font = '20px sans-serif';
                ctx.fillText(`HIGH SCORE: ${gameState.highScore}`, CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 150);

                ctx.font = 'bold 24px sans-serif';
                ctx.fillText('Press SPACE to START', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 200);
            }

            if (gameState.state === 'PAUSED') {
                // Draw pause overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2);
            }

            if (gameState.state === 'GAMEOVER') {
                // Draw game over screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 - 50);

                ctx.font = '24px sans-serif';
                ctx.fillText(`FINAL SCORE: ${gameState.score}`, CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2);

                if (gameState.score > gameState.highScore) {
                    ctx.font = 'bold 24px sans-serif';
                    ctx.fillStyle = '#FF6B6B';
                    ctx.fillText('NEW HIGH SCORE!', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 40);
                } else {
                    ctx.font = '24px sans-serif';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(`HIGH SCORE: ${gameState.highScore}`, CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 40);
                }

                ctx.font = 'bold 24px sans-serif';
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText('Press SPACE to RESTART', CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2 + 100);
            }
        }

        function loop(now) {
            const dt = Math.min(0.033, (now - gameState.lastTime) / 1000);
            gameState.lastTime = now;

            // Handle input
            handleInput(dt);

            // Update game state
            if (gameState.state === 'PLAYING') {
                updateStarfield();
                updateInvaders(dt);
                updateBullets(dt);
                updateExplosions();
            }

            // Render
            render();

            // Request next frame
            requestAnimationFrame(loop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.ArrowLeft = true;
            if (e.key === 'ArrowRight') keys.ArrowRight = true;
            if (e.key === ' ') keys.Space = true;
            if (e.key === 'a' || e.key === 'A') keys.KeyA = true;
            if (e.key === 'd' || e.key === 'D') keys.KeyD = true;
            if (e.key === 'w' || e.key === 'W') keys.KeyW = true;
            if (e.key === 'k' || e.key === 'K') keys.KeyK = true;
            if (e.key === 'p' || e.key === 'P') keys.KeyP = true;
            if (e.key === 'Escape') keys.Escape = true;

            // Handle start/restart
            if ((e.key === ' ' || e.key === 'Enter') && (gameState.state === 'TITLE' || gameState.state === 'GAMEOVER')) {
                initGame();
                gameState.state = 'PLAYING';
                sfx.start();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.ArrowLeft = false;
            if (e.key === 'ArrowRight') keys.ArrowRight = false;
            if (e.key === ' ') keys.Space = false;
            if (e.key === 'a' || e.key === 'A') keys.KeyA = false;
            if (e.key === 'd' || e.key === 'D') keys.KeyD = false;
            if (e.key === 'w' || e.key === 'W') keys.KeyW = false;
            if (e.key === 'k' || e.key === 'K') keys.KeyK = false;
            if (e.key === 'p' || e.key === 'P') keys.KeyP = false;
            if (e.key === 'Escape') keys.Escape = false;
        });

        window.addEventListener('click', (e) => {
            // Check if click is on canvas
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if click is on title or game over screen
            if (gameState.state === 'TITLE' || gameState.state === 'GAMEOVER') {
                initGame();
                gameState.state = 'PLAYING';
                sfx.start();
            }
        });

        // Initialize game
        initGame();
        requestAnimationFrame(loop);
    </script>
</body>

</html>