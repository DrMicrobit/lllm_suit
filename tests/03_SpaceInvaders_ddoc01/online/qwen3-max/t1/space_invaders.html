<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0e17, #071029);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            max-width: 100%;
            max-height: 95vh;
        }
        
        #gameCanvas {
            display: block;
            background: #071029;
            box-shadow: 0 0 30px rgba(107, 156, 255, 0.3);
            border-radius: 8px;
            width: 100%;
            max-width: 800px;
            height: auto;
        }
        
        #titleScreen, #gameOverScreen, #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(7, 16, 41, 0.85);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            text-align: center;
            padding: 20px;
            z-index: 10;
        }
        
        #gameOverScreen, #pauseScreen {
            display: none;
        }
        
        h1 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(107, 156, 255, 0.7);
            letter-spacing: 4px;
            background: linear-gradient(to right, #6B9CFF, #FF6B6B);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        h2 {
            font-size: 2.5rem;
            margin: 15px 0;
            color: #FF6B6B;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.6;
            color: #a0b0c0;
        }
        
        .controls {
            background: rgba(30, 40, 70, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            max-width: 500px;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            color: #6B9CFF;
        }
        
        .controls ul {
            list-style: none;
            text-align: left;
        }
        
        .controls li {
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .controls li span:first-child {
            font-weight: bold;
            color: #FFD56B;
        }
        
        .btn {
            background: linear-gradient(to bottom, #6B9CFF, #3a6eb5);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            margin: 15px 0;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(107, 156, 255, 0.5);
            background: linear-gradient(to bottom, #7baeff, #4a7fca);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .score-display {
            font-size: 1.3rem;
            margin: 10px 0;
        }
        
        .high-score {
            color: #FFD56B;
            font-weight: bold;
        }
        
        .new-high-score {
            color: #FF6B6B;
            font-size: 1.5rem;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .lives-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .heart {
            width: 20px;
            height: 20px;
            background: #FF6B6B;
            margin: 0 5px;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 74%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        }
        
        .settings {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .setting-group {
            background: rgba(30, 40, 70, 0.7);
            padding: 15px;
            border-radius: 10px;
        }
        
        .setting-group h3 {
            margin-bottom: 10px;
            color: #6B9CFF;
        }
        
        select, button {
            background: rgba(20, 30, 60, 0.8);
            color: white;
            border: 1px solid #6B9CFF;
            padding: 8px 15px;
            border-radius: 5px;
        }
        
        @media (max-width: 600px) {
            h1 { font-size: 2.5rem; }
            h2 { font-size: 1.8rem; }
            .subtitle { font-size: 1rem; }
            .btn { padding: 12px 30px; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="titleScreen">
            <h1>SPACE INVADERS</h1>
            <p class="subtitle">Defend Earth from the alien invasion! Destroy all invaders before they reach the bottom.</p>
            
            <div class="controls">
                <h3>CONTROLS</h3>
                <ul>
                    <li><span>LEFT</span> - Arrow Left / A</li>
                    <li><span>RIGHT</span> - Arrow Right / D</li>
                    <li><span>SHOOT</span> - Space / W / K</li>
                    <li><span>PAUSE</span> - P / Escape</li>
                </ul>
            </div>
            
            <div class="settings">
                <div class="setting-group">
                    <h3>VOLUME</h3>
                    <select id="volumeSelect">
                        <option value="1">Normal</option>
                        <option value="0.5">Low</option>
                        <option value="0">Mute</option>
                    </select>
                </div>
            </div>
            
            <div class="score-display">
                HIGH SCORE: <span id="titleHighScore" class="high-score">0</span>
            </div>
            
            <button id="startBtn" class="btn">PRESS SPACE OR CLICK TO START</button>
        </div>
        
        <div id="gameOverScreen">
            <h2>GAME OVER</h2>
            <div class="score-display">
                FINAL SCORE: <span id="finalScore">0</span>
            </div>
            <div class="score-display">
                HIGH SCORE: <span id="gameOverHighScore" class="high-score">0</span>
            </div>
            <div id="newHighScoreMsg" class="new-high-score" style="display: none;">
                NEW HIGH SCORE!
            </div>
            <button id="restartBtn" class="btn">PRESS SPACE OR CLICK TO RESTART</button>
        </div>
        
        <div id="pauseScreen">
            <h2>PAUSED</h2>
            <p class="subtitle">Press P or ESC to continue</p>
        </div>
    </div>

    <script>
        // Game constants
        const CONFIG = {
            CANVAS_W: 800,
            CANVAS_H: 600,
            HUD_HEIGHT: 48,
            INVADER_ROWS: 5,
            INVADER_COLS: 11,
            INVADER_WIDTH: 40,
            INVADER_HEIGHT: 32,
            INVADER_H_SPACING: 8,
            INVADER_V_SPACING: 12,
            FORMATION_START_Y: 80,
            PLAYER_Y: 540,
            PLAYER_WIDTH: 48,
            PLAYER_HEIGHT: 20,
            PLAYER_SPEED: 260,
            PLAYER_BULLET_SPEED: 420,
            INVADER_BASE_SPEED: 22,
            INVADER_DROP_AMOUNT: 18,
            INVADER_ANIM_INTERVAL: 0.45,
            BUNKER_Y: 460,
            BUNKER_WIDTH: 70,
            BUNKER_HEIGHT: 48,
            BLOCK_WIDTH: 14,
            BLOCK_HEIGHT: 12,
            BLOCK_SPACING: 2,
            UFO_SPEED: 140,
            UFO_SPAWN_CHANCE: 0.001,
            INVADER_SHOOT_BASE_RATE: 1.1, // seconds between shots
            MAX_INVADER_BULLETS: 6
        };

        // Game state
        const STATE = {
            TITLE: 'title',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };

        // Invader row colors and points
        const INVADER_COLORS = [
            { color: '#FF6B6B', points: 30 }, // top row
            { color: '#FFB86B', points: 20 },
            { color: '#FFD56B', points: 20 },
            { color: '#6BFFB8', points: 10 },
            { color: '#6B9CFF', points: 10 }  // bottom row
        ];

        // Game variables
        let gameState = STATE.TITLE;
        let canvas, ctx;
        let lastTime = 0;
        let deltaTime = 0;
        let keys = {};
        let score = 0;
        let highScore = localStorage.getItem('space_invaders_highscore_v1') || 0;
        let level = 1;
        let lives = 3;
        let invaderSpeed = CONFIG.INVADER_BASE_SPEED;
        let invaderFormation = [];
        let player = { x: CONFIG.CANVAS_W / 2, y: CONFIG.PLAYER_Y, width: CONFIG.PLAYER_WIDTH, height: CONFIG.PLAYER_HEIGHT };
        let playerBullets = [];
        let invaderBullets = [];
        let bunkers = [];
        let explosions = [];
        let ufo = null;
        let invaderDirection = 1; // 1 for right, -1 for left
        let invaderAnimTimer = 0;
        let invaderFrame = 0;
        let invaderShootTimer = 0;
        let ufoTimer = 0;
        let playerRespawnTimer = 0;
        let playerInvulnerable = false;
        let volume = 1.0;
        
        // Audio context
        let audioContext;
        let audioBuffers = {};

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set high score display
            document.getElementById('titleHighScore').textContent = highScore;
            document.getElementById('gameOverHighScore').textContent = highScore;
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            canvas.addEventListener('click', () => {
                if (gameState === STATE.TITLE) startGame();
                if (gameState === STATE.GAME_OVER) restartGame();
            });
            
            // Volume control
            document.getElementById('volumeSelect').addEventListener('change', (e) => {
                volume = parseFloat(e.target.value);
            });
            
            // Initialize audio
            initAudio();
            
            // Create initial game objects
            createInvaderFormation();
            createBunkers();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Initialize audio
        function initAudio() {
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Create simple sounds using oscillators
                // Player shot
                audioBuffers.shot = createToneBuffer(600, 0.1, 'square');
                
                // Invader shot
                audioBuffers.invaderShot = createToneBuffer(300, 0.2, 'square');
                
                // Invader death
                audioBuffers.invaderDeath = createNoiseBuffer(0.2, 0.1);
                
                // Player death
                audioBuffers.playerDeath = createNoiseBuffer(0.3, 0.2);
                
                // Block hit
                audioBuffers.blockHit = createToneBuffer(200, 0.1, 'sine');
                
                // UFO
                audioBuffers.ufo = createToneBuffer(200, 0.5, 'sawtooth', true);
                
                // Start sound
                audioBuffers.start = createToneBuffer(440, 0.2, 'sine');
                
                // Game over
                audioBuffers.gameOver = createToneBuffer(200, 0.3, 'sine');
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }

        // Create a tone buffer
        function createToneBuffer(frequency, duration, type, loop = false) {
            if (!audioContext) return null;
            
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const buffer = audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < length; i++) {
                const time = i / sampleRate;
                if (type === 'sine') {
                    data[i] = Math.sin(2 * Math.PI * frequency * time) * 0.3;
                } else if (type === 'square') {
                    data[i] = (Math.sin(2 * Math.PI * frequency * time) > 0) ? 0.3 : -0.3;
                } else if (type === 'sawtooth') {
                    data[i] = (2 * (time * frequency - Math.floor(0.5 + time * frequency))) * 0.3;
                } else {
                    data[i] = Math.sin(2 * Math.PI * frequency * time) * 0.3;
                }
                
                // Apply simple envelope
                const attack = Math.min(1, time * 20);
                const release = Math.min(1, (duration - time) * 10);
                data[i] *= attack * release;
            }
            
            return buffer;
        }

        // Create noise buffer
        function createNoiseBuffer(duration, cutoff) {
            if (!audioContext) return null;
            
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const buffer = audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            // White noise
            for (let i = 0; i < length; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.3;
            }
            
            // Simple low-pass filter effect
            for (let i = 1; i < length; i++) {
                data[i] = data[i] * (1 - cutoff) + data[i-1] * cutoff;
            }
            
            return buffer;
        }

        // Play sound
        function playSFX(name) {
            if (!audioContext || volume === 0) return;
            
            try {
                const buffer = audioBuffers[name];
                if (!buffer) return;
                
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                source.start();
            } catch (e) {
                console.log('Error playing sound:', e);
            }
        }

        // Create invader formation
        function createInvaderFormation() {
            invaderFormation = [];
            const totalWidth = (CONFIG.INVADER_COLS - 1) * (CONFIG.INVADER_WIDTH + CONFIG.INVADER_H_SPACING) + CONFIG.INVADER_WIDTH;
            const startX = (CONFIG.CANVAS_W - totalWidth) / 2;
            
            for (let row = 0; row < CONFIG.INVADER_ROWS; row++) {
                for (let col = 0; col < CONFIG.INVADER_COLS; col++) {
                    invaderFormation.push({
                        x: startX + col * (CONFIG.INVADER_WIDTH + CONFIG.INVADER_H_SPACING),
                        y: CONFIG.FORMATION_START_Y + row * (CONFIG.INVADER_HEIGHT + CONFIG.INVADER_V_SPACING),
                        width: CONFIG.INVADER_WIDTH,
                        height: CONFIG.INVADER_HEIGHT,
                        row: row,
                        alive: true,
                        hitbox: {
                            x: 6,
                            y: 6,
                            width: CONFIG.INVADER_WIDTH - 12,
                            height: CONFIG.INVADER_HEIGHT - 12
                        }
                    });
                }
            }
            
            // Reset formation direction
            invaderDirection = 1;
        }

        // Create bunkers
        function createBunkers() {
            bunkers = [];
            const bunkerXPositions = [100, 270, 530, 700];
            
            for (let i = 0; i < bunkerXPositions.length; i++) {
                const bunker = {
                    x: bunkerXPositions[i],
                    y: CONFIG.BUNKER_Y,
                    blocks: []
                };
                
                // Create 4x5 grid of blocks
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        bunker.blocks.push({
                            x: col * (CONFIG.BLOCK_WIDTH + CONFIG.BLOCK_SPACING),
                            y: row * (CONFIG.BLOCK_HEIGHT + CONFIG.BLOCK_SPACING),
                            width: CONFIG.BLOCK_WIDTH,
                            height: CONFIG.BLOCK_HEIGHT,
                            alive: true
                        });
                    }
                }
                
                bunkers.push(bunker);
            }
        }

        // Start the game
        function startGame() {
            if (gameState === STATE.TITLE) {
                gameState = STATE.PLAYING;
                document.getElementById('titleScreen').style.display = 'none';
                score = 0;
                lives = 3;
                level = 1;
                invaderSpeed = CONFIG.INVADER_BASE_SPEED;
                player.x = CONFIG.CANVAS_W / 2;
                playerInvulnerable = false;
                playerRespawnTimer = 0;
                playerBullets = [];
                invaderBullets = [];
                explosions = [];
                ufo = null;
                invaderAnimTimer = 0;
                invaderFrame = 0;
                invaderShootTimer = 0;
                ufoTimer = 0;
                
                createInvaderFormation();
                createBunkers();
                
                playSFX('start');
            }
        }

        // Restart the game
        function restartGame() {
            if (gameState === STATE.GAME_OVER) {
                document.getElementById('gameOverScreen').style.display = 'none';
                startGame();
            }
        }

        // Handle key down
        function handleKeyDown(e) {
            keys[e.key] = true;
            
            // Prevent scrolling with spacebar
            if (e.key === ' ') {
                e.preventDefault();
            }
            
            // Game controls
            if (gameState === STATE.TITLE && (e.key === ' ' || e.key === 'Enter')) {
                startGame();
            } else if (gameState === STATE.GAME_OVER && (e.key === ' ' || e.key === 'Enter')) {
                restartGame();
            } else if (gameState === STATE.PLAYING) {
                if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                    gameState = gameState === STATE.PAUSED ? STATE.PLAYING : STATE.PAUSED;
                    document.getElementById('pauseScreen').style.display = 
                        gameState === STATE.PAUSED ? 'flex' : 'none';
                } else if (e.key === ' ' || e.key === 'w' || e.key === 'W' || e.key === 'k' || e.key === 'K') {
                    shootPlayerBullet();
                }
            }
        }

        // Handle key up
        function handleKeyUp(e) {
            keys[e.key] = false;
        }

        // Shoot player bullet
        function shootPlayerBullet() {
            if (gameState !== STATE.PLAYING || playerRespawnTimer > 0) return;
            
            // Only one bullet at a time (classic)
            if (playerBullets.length === 0) {
                playerBullets.push({
                    x: player.x,
                    y: player.y - 10,
                    width: 4,
                    height: 12,
                    speed: -CONFIG.PLAYER_BULLET_SPEED
                });
                
                playSFX('shot');
            }
        }

        // Update game
        function update() {
            if (gameState !== STATE.PLAYING) return;
            
            // Update player
            updatePlayer();
            
            // Update bullets
            updateBullets();
            
            // Update invaders
            updateInvaders();
            
            // Update bunkers
            updateBunkers();
            
            // Update explosions
            updateExplosions();
            
            // Update UFO
            updateUFO();
            
            // Check for level completion
            checkLevelCompletion();
            
            // Check for game over
            checkGameOver();
        }

        // Update player
        function updatePlayer() {
            // Movement
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.x -= CONFIG.PLAYER_SPEED * deltaTime;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.x += CONFIG.PLAYER_SPEED * deltaTime;
            }
            
            // Keep player in bounds
            player.x = Math.max(player.width / 2, Math.min(CONFIG.CANVAS_W - player.width / 2, player.x));
            
            // Invulnerability timer
            if (playerInvulnerable) {
                playerRespawnTimer -= deltaTime;
                if (playerRespawnTimer <= 0) {
                    playerInvulnerable = false;
                }
            }
        }

        // Update bullets
        function updateBullets() {
            // Player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.y += bullet.speed * deltaTime;
                
                // Remove if out of bounds
                if (bullet.y < 0) {
                    playerBullets.splice(i, 1);
                    continue;
                }
                
                // Check collisions with invaders
                for (let j = invaderFormation.length - 1; j >= 0; j--) {
                    const invader = invaderFormation[j];
                    if (invader.alive) {
                        const hitbox = {
                            x: invader.x + invader.hitbox.x,
                            y: invader.y + invader.hitbox.y,
                            width: invader.hitbox.width,
                            height: invader.hitbox.height
                        };
                        
                        if (collision(bullet, hitbox)) {
                            invader.alive = false;
                            score += INVADER_COLORS[invader.row].points;
                            playerBullets.splice(i, 1);
                            createExplosion(invader.x + invader.width/2, invader.y + invader.height/2);
                            playSFX('invaderDeath');
                            break;
                        }
                    }
                }
                
                // Check collisions with UFO
                if (ufo && ufo.alive) {
                    if (collision(bullet, ufo)) {
                        ufo.alive = false;
                        score += ufo.points;
                        playerBullets.splice(i, 1);
                        createExplosion(ufo.x + ufo.width/2, ufo.y + ufo.height/2);
                        playSFX('invaderDeath');
                    }
                }
                
                // Check collisions with bunker blocks
                for (const bunker of bunkers) {
                    for (let j = bunker.blocks.length - 1; j >= 0; j--) {
                        const block = bunker.blocks[j];
                        if (block.alive) {
                            const blockRect = {
                                x: bunker.x + block.x,
                                y: bunker.y + block.y,
                                width: block.width,
                                height: block.height
                            };
                            
                            if (collision(bullet, blockRect)) {
                                block.alive = false;
                                playerBullets.splice(i, 1);
                                playSFX('blockHit');
                                break;
                            }
                        }
                    }
                }
                
                // Check collisions with invader bullets
                for (let j = invaderBullets.length - 1; j >= 0; j--) {
                    if (collision(bullet, invaderBullets[j])) {
                        playerBullets.splice(i, 1);
                        invaderBullets.splice(j, 1);
                        break;
                    }
                }
            }
            
            // Invader bullets
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                const bullet = invaderBullets[i];
                bullet.y += bullet.speed * deltaTime;
                
                // Remove if out of bounds
                if (bullet.y > CONFIG.CANVAS_H) {
                    invaderBullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (!playerInvulnerable && collision(bullet, player)) {
                    invaderBullets.splice(i, 1);
                    playerHit();
                    continue;
                }
                
                // Check collisions with bunker blocks
                for (const bunker of bunkers) {
                    for (let j = bunker.blocks.length - 1; j >= 0; j--) {
                        const block = bunker.blocks[j];
                        if (block.alive) {
                            const blockRect = {
                                x: bunker.x + block.x,
                                y: bunker.y + block.y,
                                width: block.width,
                                height: block.height
                            };
                            
                            if (collision(bullet, blockRect)) {
                                block.alive = false;
                                invaderBullets.splice(i, 1);
                                playSFX('blockHit');
                                break;
                            }
                        }
                    }
                }
            }
        }

        // Update invaders
        function updateInvaders() {
            // Animation timer
            invaderAnimTimer += deltaTime;
            if (invaderAnimTimer > CONFIG.INVADER_ANIM_INTERVAL * (1 - getAliveInvaderRatio() * 0.5)) {
                invaderAnimTimer = 0;
                invaderFrame = 1 - invaderFrame; // Toggle between 0 and 1
            }
            
            // Shooting timer
            invaderShootTimer -= deltaTime;
            if (invaderShootTimer <= 0) {
                shootInvaderBullet();
                // Adjust shoot rate based on number of invaders and level
                const baseRate = CONFIG.INVADER_SHOOT_BASE_RATE * (0.7 + 0.3 * getAliveInvaderRatio());
                invaderShootTimer = baseRate / level;
            }
            
            // Move formation
            let moveDown = false;
            let edgeReached = false;
            
            // Check if formation hits edges
            for (const invader of invaderFormation) {
                if (invader.alive) {
                    const nextX = invader.x + invaderDirection * invaderSpeed * deltaTime;
                    if (nextX < 16 || nextX + invader.width > CONFIG.CANVAS_W - 16) {
                        edgeReached = true;
                        break;
                    }
                }
            }
            
            if (edgeReached) {
                moveDown = true;
                invaderDirection *= -1;
            }
            
            // Update positions
            for (const invader of invaderFormation) {
                if (invader.alive) {
                    if (moveDown) {
                        invader.y += CONFIG.INVADER_DROP_AMOUNT;
                    } else {
                        invader.x += invaderDirection * invaderSpeed * deltaTime;
                    }
                }
            }
            
            // Check if invaders reached the bottom
            for (const invader of invaderFormation) {
                if (invader.alive && invader.y + invader.height >= CONFIG.PLAYER_Y - 20) {
                    // Game over immediately
                    lives = 0;
                    checkGameOver();
                    break;
                }
            }
        }

        // Shoot invader bullet
        function shootInvaderBullet() {
            if (invaderBullets.length >= CONFIG.MAX_INVADER_BULLETS) return;
            
            // Find bottom-most alive invaders in each column
            const columns = {};
            for (const invader of invaderFormation) {
                if (invader.alive) {
                    const col = Math.floor((invader.x - 200) / (CONFIG.INVADER_WIDTH + CONFIG.INVADER_H_SPACING));
                    if (!columns[col] || invader.y > columns[col].y) {
                        columns[col] = invader;
                    }
                }
            }
            
            // Randomly select a column to shoot from
            const cols = Object.values(columns);
            if (cols.length > 0) {
                const shooter = cols[Math.floor(Math.random() * cols.length)];
                
                invaderBullets.push({
                    x: shooter.x + shooter.width / 2,
                    y: shooter.y + shooter.height,
                    width: 4,
                    height: 12,
                    speed: 190
                });
                
                playSFX('invaderShot');
            }
        }

        // Update bunkers
        function updateBunkers() {
            // Nothing to update for bunkers, they're updated during bullet collisions
        }

        // Update explosions
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].timer -= deltaTime;
                if (explosions[i].timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        // Update UFO
        function updateUFO() {
            ufoTimer -= deltaTime;
            
            // Randomly spawn UFO
            if (ufo === null && ufoTimer <= 0 && Math.random() < CONFIG.UFO_SPAWN_CHANCE) {
                ufo = {
                    x: -50,
                    y: 60,
                    width: 60,
                    height: 25,
                    alive: true,
                    speed: CONFIG.UFO_SPEED,
                    points: 50 + Math.floor(Math.random() * 251) // 50-300 points
                };
                ufoTimer = 10; // Reset timer
                playSFX('ufo');
            }
            
            // Move UFO
            if (ufo) {
                ufo.x += ufo.speed * deltaTime;
                
                // Remove if out of bounds
                if (ufo.x > CONFIG.CANVAS_W + 50) {
                    ufo = null;
                }
            }
        }

        // Check level completion
        function checkLevelCompletion() {
            let allDead = true;
            for (const invader of invaderFormation) {
                if (invader.alive) {
                    allDead = false;
                    break;
                }
            }
            
            if (allDead) {
                level++;
                invaderSpeed *= 1.12; // Increase speed by 12%
                CONFIG.INVADER_ANIM_INTERVAL *= 0.92; // Decrease animation interval
                createInvaderFormation();
                createBunkers(); // Reset bunkers
            }
        }

        // Check game over
        function checkGameOver() {
            if (lives <= 0) {
                gameState = STATE.GAME_OVER;
                
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('space_invaders_highscore_v1', highScore);
                    
                    // Show new high score message
                    document.getElementById('newHighScoreMsg').style.display = 'block';
                } else {
                    document.getElementById('newHighScoreMsg').style.display = 'none';
                }
                
                // Update displays
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOverHighScore').textContent = highScore;
                document.getElementById('titleHighScore').textContent = highScore;
                
                document.getElementById('gameOverScreen').style.display = 'flex';
                playSFX('gameOver');
            }
        }

        // Player hit
        function playerHit() {
            lives--;
            playSFX('playerDeath');
            createExplosion(player.x, player.y);
            
            if (lives > 0) {
                // Respawn player
                playerInvulnerable = true;
                playerRespawnTimer = 1.5; // 1.5 seconds of invulnerability
                player.x = CONFIG.CANVAS_W / 2;
            }
        }

        // Create explosion
        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                timer: 0.3, // 0.3 seconds
                size: 20
            });
        }

        // Get ratio of alive invaders
        function getAliveInvaderRatio() {
            let alive = 0;
            for (const invader of invaderFormation) {
                if (invader.alive) alive++;
            }
            return alive / invaderFormation.length;
        }

        // Collision detection (AABB)
        function collision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Render game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#071029';
            ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);
            
            // Draw starfield (simple parallax)
            drawStarfield();
            
            // Draw HUD background
            ctx.fillStyle = 'rgba(10, 20, 40, 0.7)';
            ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.HUD_HEIGHT);
            
            // Draw invaders
            drawInvaders();
            
            // Draw UFO
            drawUFO();
            
            // Draw invader bullets
            drawBullets(invaderBullets, '#FF6B6B');
            
            // Draw bunkers
            drawBunkers();
            
            // Draw player bullets
            drawBullets(playerBullets, '#6B9CFF');
            
            // Draw player
            drawPlayer();
            
            // Draw explosions
            drawExplosions();
            
            // Draw HUD
            drawHUD();
        }

        // Draw starfield
        function drawStarfield() {
            // For simplicity, we'll draw a static starfield
            // In a real implementation, you'd animate this
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            // Small stars
            for (let i = 0; i < 100; i++) {
                const x = (i * 73) % CONFIG.CANVAS_W;
                const y = (i * 57) % CONFIG.CANVAS_H;
                const size = Math.random() * 1.5;
                ctx.fillRect(x, y, size, size);
            }
            
            // Larger stars
            ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
            for (let i = 0; i < 20; i++) {
                const x = (i * 113) % CONFIG.CANVAS_W;
                const y = (i * 89) % CONFIG.CANVAS_H;
                const size = 1.5 + Math.random() * 1.5;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw invaders
        function drawInvaders() {
            for (const invader of invaderFormation) {
                if (!invader.alive) continue;
                
                const color = INVADER_COLORS[invader.row].color;
                const x = invader.x;
                const y = invader.y;
                const w = invader.width;
                const h = invader.height;
                
                // Draw invader body with glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = color;
                ctx.beginPath();
                
                // Draw invader shape (simplified classic shape)
                if (invaderFrame === 0) {
                    // Frame 1: more closed
                    ctx.moveTo(x, y + h/2);
                    ctx.lineTo(x + w/4, y);
                    ctx.lineTo(x + 3*w/4, y);
                    ctx.lineTo(x + w, y + h/2);
                    ctx.lineTo(x + 3*w/4, y + h);
                    ctx.lineTo(x + w/4, y + h);
                    ctx.closePath();
                } else {
                    // Frame 2: more open
                    ctx.moveTo(x, y + h/2);
                    ctx.lineTo(x + w/6, y + h/4);
                    ctx.lineTo(x + w/3, y);
                    ctx.lineTo(x + 2*w/3, y);
                    ctx.lineTo(x + 5*w/6, y + h/4);
                    ctx.lineTo(x + w, y + h/2);
                    ctx.lineTo(x + 5*w/6, y + 3*h/4);
                    ctx.lineTo(x + 2*w/3, y + h);
                    ctx.lineTo(x + w/3, y + h);
                    ctx.lineTo(x + w/6, y + 3*h/4);
                    ctx.closePath();
                }
                
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw eyes
                ctx.fillStyle = '#071029';
                ctx.beginPath();
                ctx.arc(x + w/3, y + h/3, 3, 0, Math.PI * 2);
                ctx.arc(x + 2*w/3, y + h/3, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw UFO
        function drawUFO() {
            if (!ufo) return;
            
            const x = ufo.x;
            const y = ufo.y;
            const w = ufo.width;
            const h = ufo.height;
            
            // Draw UFO body
            ctx.fillStyle = '#FFD56B';
            ctx.beginPath();
            ctx.moveTo(x, y + h/2);
            ctx.lineTo(x + w/4, y);
            ctx.lineTo(x + 3*w/4, y);
            ctx.lineTo(x + w, y + h/2);
            ctx.lineTo(x + 3*w/4, y + h);
            ctx.lineTo(x + w/4, y + h);
            ctx.closePath();
            ctx.fill();
            
            // Draw UFO cockpit
            ctx.fillStyle = '#6B9CFF';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2, w/6, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw bullets
        function drawBullets(bullets, color) {
            ctx.fillStyle = color;
            for (const bullet of bullets) {
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
            }
        }

        // Draw bunkers
        function drawBunkers() {
            for (const bunker of bunkers) {
                for (const block of bunker.blocks) {
                    if (!block.alive) continue;
                    
                    const x = bunker.x + block.x;
                    const y = bunker.y + block.y;
                    const w = block.width;
                    const h = block.height;
                    
                    // Draw block with 3D effect
                    ctx.fillStyle = '#2E8B57';
                    ctx.fillRect(x, y, w, h);
                    
                    // Top highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(x, y, w, 2);
                    ctx.fillRect(x, y, 2, h);
                    
                    // Bottom shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(x, y + h - 2, w, 2);
                    ctx.fillRect(x + w - 2, y, 2, h);
                }
            }
        }

        // Draw player
        function drawPlayer() {
            // Draw player ship with glow effect
            ctx.shadowColor = '#6B9CFF';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#FFFFFF';
            
            const x = player.x;
            const y = player.y;
            const w = player.width;
            const h = player.height;
            
            // Draw wedge shape
            ctx.beginPath();
            ctx.moveTo(x, y - h/2);
            ctx.lineTo(x - w/2, y + h/2);
            ctx.lineTo(x + w/2, y + h/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw engine glow
            ctx.fillStyle = '#6B9CFF';
            ctx.beginPath();
            ctx.moveTo(x - w/4, y + h/2);
            ctx.lineTo(x, y + h);
            ctx.lineTo(x + w/4, y + h/2);
            ctx.closePath();
            ctx.fill();
            
            // Disable shadow for next drawings
            ctx.shadowBlur = 0;
            
            // Draw invulnerability effect (flickering)
            if (playerInvulnerable && Math.floor(playerRespawnTimer * 10) % 2 === 0) {
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, w/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Draw explosions
        function drawExplosions() {
            for (const explosion of explosions) {
                const opacity = explosion.timer / 0.3;
                
                // Draw explosion particles
                ctx.fillStyle = `rgba(255, 107, 107, ${opacity})`;
                ctx.beginPath();
                
                // Outer ring
                ctx.arc(explosion.x, explosion.y, explosion.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner core
                ctx.fillStyle = `rgba(255, 213, 107, ${opacity * 0.8})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw HUD
        function drawHUD() {
            // Score
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score.toString().padStart(5, '0')}`, 20, 30);
            
            // High score
            ctx.textAlign = 'center';
            ctx.fillText(`HIGH SCORE: ${highScore.toString().padStart(5, '0')}`, CONFIG.CANVAS_W / 2, 30);
            
            // Lives and level
            ctx.textAlign = 'right';
            let livesText = `LIVES: `;
            for (let i = 0; i < lives; i++) {
                livesText += 'â™¥';
            }
            livesText += `  LEVEL: ${level}`;
            ctx.fillText(livesText, CONFIG.CANVAS_W - 20, 30);
        }

        // Game loop
        function gameLoop(timestamp) {
            // Calculate delta time
            if (lastTime === 0) lastTime = timestamp;
            deltaTime = Math.min(0.033, (timestamp - lastTime) / 1000);
            lastTime = timestamp;
            
            // Update and render
            update();
            render();
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Initialize game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>