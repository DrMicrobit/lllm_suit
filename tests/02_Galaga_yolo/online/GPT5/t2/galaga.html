<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Galaga-ish (HTML Canvas)</title>
  <style>
    :root {
      color-scheme: dark;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
      touch-action: none;
      cursor: crosshair;
    }

    /* Mobile touch controls */
    #touchControls {
      position: fixed;
      bottom: 2.5vh;
      left: 0;
      right: 0;
      display: flex;
      gap: 2.5vh;
      justify-content: center;
      pointer-events: none;
    }

    .tc-btn {
      pointer-events: auto;
      width: 22vw;
      max-width: 200px;
      height: 8.5vh;
      max-height: 80px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(4px);
      background: rgba(255, 255, 255, 0.07);
      color: #fff;
      font-weight: 700;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
    }

    .tc-btn:active {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(0.98);
    }

    /* Tiny watermark link */
    #credit {
      position: fixed;
      top: 8px;
      right: 12px;
      color: rgba(255, 255, 255, 0.35);
      font-size: 12px;
      text-decoration: none;
    }

    #credit:hover {
      color: rgba(255, 255, 255, 0.8);
    }
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div id="touchControls">
    <div class="tc-btn" id="btnLeft">Left</div>
    <div class="tc-btn" id="btnRight">Right</div>
    <div class="tc-btn" id="btnFire">Fire</div>
  </div>

  <a id="credit" href="#" onclick="return false;">Galaga-ish</a>

  <script>
    (() => {
      // --- Canvas & sizing ---
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: false });
      let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR a bit
      let CW = 0, CH = 0; // CSS pixel size

      function resize() {
        DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(window.innerWidth * DPR);
        canvas.height = Math.floor(window.innerHeight * DPR);
        CW = canvas.width / DPR;
        CH = canvas.height / DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // draw in CSS pixels
      }
      window.addEventListener('resize', resize);

      // --- Utilities ---
      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const rand = (a = 0, b = 1) => a + Math.random() * (b - a);
      const randi = (a, b) => Math.floor(rand(a, b + 1));
      const now = () => performance.now() / 1000; // seconds
      const dist2 = (ax, ay, bx, by) => {
        const dx = ax - bx, dy = ay - by;
        return dx * dx + dy * dy;
      };
      const ease = (t) => t < 0 ? 0 : (t > 1 ? 1 : (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t)); // easeInOutQuad

      // --- Input ---
      const keys = { left: false, right: false, fire: false, pause: false };
      const keyMapDown = (e) => {
        switch (e.code) {
          case 'ArrowLeft': case 'KeyA': keys.left = true; break;
          case 'ArrowRight': case 'KeyD': keys.right = true; break;
          case 'Space': keys.fire = true; e.preventDefault(); break;
          case 'KeyP': keys.pause = true; break;
          case 'Enter': startIfMenu(); break;
          case 'KeyM': toggleSound(); break;
        }
      };
      const keyMapUp = (e) => {
        switch (e.code) {
          case 'ArrowLeft': case 'KeyA': keys.left = false; break;
          case 'ArrowRight': case 'KeyD': keys.right = false; break;
          case 'Space': keys.fire = false; e.preventDefault(); break;
          case 'KeyP': keys.pause = false; break;
        }
      };
      window.addEventListener('keydown', keyMapDown);
      window.addEventListener('keyup', keyMapUp);

      // Touch controls
      const btnLeft = document.getElementById('btnLeft');
      const btnRight = document.getElementById('btnRight');
      const btnFire = document.getElementById('btnFire');

      function bindTouchHold(el, on, off) {
        const start = (e) => { e.preventDefault(); on(); enableAudio(); };
        const end = (e) => { e.preventDefault(); off(); };
        el.addEventListener('touchstart', start, { passive: false });
        el.addEventListener('touchend', end, { passive: false });
        el.addEventListener('touchcancel', end, { passive: false });
        el.addEventListener('mousedown', start);
        window.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }
      bindTouchHold(btnLeft, () => keys.left = true, () => keys.left = false);
      bindTouchHold(btnRight, () => keys.right = true, () => keys.right = false);
      bindTouchHold(btnFire, () => keys.fire = true, () => keys.fire = false);

      // --- Audio (minimal, optional) ---
      let audioCtx = null;
      let audioOn = false;
      function enableAudio() {
        if (!audioCtx) {
          try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {
            audioCtx = null;
          }
        }
      }
      function toggleSound() {
        enableAudio();
        audioOn = !audioOn;
        toast(audioOn ? 'Sound ON' : 'Sound OFF');
      }
      function tone(freq = 440, dur = 0.06, type = 'square', vol = 0.05) {
        if (!audioOn || !audioCtx) return;
        const t0 = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = vol;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t0);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + Math.max(0.02, dur));
        osc.stop(t0 + Math.max(0.03, dur));
      }

      // --- Game state ---
      const G = {
        mode: 'menu', // 'menu', 'playing', 'paused', 'gameover'
        t: 0,
        dt: 0,
        score: 0,
        hi: Number(localStorage.getItem('galaga_hi') || 0),
        lives: 3,
        level: 1,
        player: null,
        bullets: [],
        enemyBullets: [],
        enemies: [],
        particles: [],
        stars: [],
        nextDiveAt: 0,
        lastFrameAt: now(),
        stageBannerT: -1,
        invincibleT: 0,
      };

      function resetGame() {
        G.score = 0;
        G.lives = 3;
        G.level = 1;
        G.bullets.length = 0;
        G.enemyBullets.length = 0;
        G.enemies.length = 0;
        G.particles.length = 0;
        G.invincibleT = 0;
        spawnPlayer();
        spawnStars();
        spawnWave(G.level);
        G.stageBannerT = 2.5;
      }

      function startIfMenu() {
        if (G.mode === 'menu' || G.mode === 'gameover') {
          G.mode = 'playing';
          resetGame();
          enableAudio();
        }
      }

      // --- Player ---
      function spawnPlayer() {
        const y = CH - 70;
        G.player = {
          x: CW * 0.5,
          y,
          w: 28,
          h: 22,
          speed: 300,
          cooldown: 0,
          alive: true,
          blinkT: 0
        };
      }

      function playerShoot() {
        const p = G.player;
        if (!p.alive) return;
        const limit = 2;
        const activeBullets = G.bullets.length;
        if (p.cooldown <= 0 && activeBullets < limit) {
          G.bullets.push({
            x: p.x,
            y: p.y - p.h * 0.5 - 6,
            vx: 0,
            vy: -500,
            r: 3,
            color: '#9cf',
            life: 2
          });
          p.cooldown = 0.2;
          tone(880, 0.05, 'square', 0.03);
        }
      }

      // --- Enemies ---
      function spawnWave(level = 1) {
        G.enemies.length = 0;
        const cols = Math.max(8, Math.min(12, Math.floor(CW / 70)));
        const rows = 5;
        const gridW = Math.min(CW * 0.9, cols * 46);
        const left = (CW - gridW) * 0.5;
        const top = 70;
        const spacingX = gridW / cols;
        const spacingY = 42;
        const speedBoost = 1 + (level - 1) * 0.07;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const fx = left + c * spacingX + spacingX * 0.5;
            const fy = top + r * spacingY;
            const type = (r < 1) ? 'scout' : (r < 3 ? 'fighter' : 'boss');
            const color = (type === 'scout') ? '#5cf'
              : (type === 'fighter') ? '#fc5'
                : '#f55';
            const score = (type === 'scout') ? 60 : (type === 'fighter') ? 80 : 150;
            G.enemies.push({
              x: fx,
              y: fy - 200,        // drop-in effect
              fx, fy,
              w: 26, h: 22,
              type, color, score,
              state: 'enter',     // 'enter' -> 'formation' -> 'dive' -> 'return'
              bobPhase: rand(0, Math.PI * 2),
              diveT: 0,
              diveDir: Math.random() < 0.5 ? -1 : 1,
              speed: (type === 'scout' ? 150 : type === 'fighter' ? 170 : 190) * speedBoost,
              shootCD: rand(0.8, 1.6) / speedBoost,
              hp: 1,
              alive: true
            });
          }
        }
        // schedule dives
        G.nextDiveAt = G.t + rand(1.5, 3.0);
      }

      function pickDivers(count = 1) {
        const formation = G.enemies.filter(e => e.alive && e.state === 'formation');
        if (formation.length === 0) return;
        formation.sort((a, b) => a.fy - b.fy); // prefer front rows
        for (let i = 0; i < Math.min(count, formation.length); i++) {
          const e = formation[randi(0, Math.min(formation.length - 1, 6))]; // random among first few
          e.state = 'dive';
          e.diveT = 0;
          e.diveDir = Math.random() < 0.5 ? -1 : 1;
          e.shootCD = rand(0.3, 0.8);
        }
      }

      // --- Stars ---
      function spawnStars() {
        const layers = 3;
        const count = Math.floor((CW * CH) / (9000)) + 60;
        G.stars.length = 0;
        for (let i = 0; i < count; i++) {
          const layer = randi(0, layers - 1);
          const speed = 20 + layer * 30;
          G.stars.push({
            x: rand(0, CW),
            y: rand(0, CH),
            r: (layer + 1) * 0.7,
            speed,
            alpha: 0.35 + layer * 0.2
          });
        }
      }

      // --- Particles ---
      function explode(x, y, color = '#fff', count = 12) {
        for (let i = 0; i < count; i++) {
          const a = rand(0, Math.PI * 2);
          const s = rand(80, 220);
          G.particles.push({
            x, y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            life: rand(0.3, 0.8),
            r: rand(1.5, 2.5),
            color
          });
        }
        tone(220, 0.09, 'sawtooth', 0.04);
      }

      // --- Collision helpers ---
      function rectHit(ax, ay, aw, ah, bx, by, bw, bh) {
        return Math.abs(ax - bx) < (aw * 0.5 + bw * 0.5) && Math.abs(ay - by) < (ah * 0.5 + bh * 0.5);
      }

      // --- Drawing ---
      function drawShip(x, y, w, h, color = '#9cf', inv = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        // fuselage
        ctx.beginPath();
        ctx.moveTo(0, -h * 0.5);
        ctx.lineTo(w * 0.35, h * 0.35);
        ctx.lineTo(0, h * 0.5);
        ctx.lineTo(-w * 0.35, h * 0.35);
        ctx.closePath();
        ctx.fill();

        // wings
        ctx.beginPath();
        ctx.moveTo(-w * 0.55, 0);
        ctx.lineTo(-w * 0.15, -h * 0.05);
        ctx.lineTo(-w * 0.1, h * 0.15);
        ctx.lineTo(-w * 0.55, h * 0.1);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(w * 0.55, 0);
        ctx.lineTo(w * 0.15, -h * 0.05);
        ctx.lineTo(w * 0.1, h * 0.15);
        ctx.lineTo(w * 0.55, h * 0.1);
        ctx.closePath();
        ctx.fill();

        if (inv) {
          ctx.globalCompositeOperation = 'lighter';
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.strokeRect(-w * 0.55, -h * 0.5, w * 1.1, h);
        }

        ctx.restore();
      }

      function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.fillStyle = e.color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        // Simple bug-like silhouette
        const w = e.w, h = e.h;
        ctx.beginPath();
        ctx.moveTo(-w * 0.4, -h * 0.2);
        ctx.quadraticCurveTo(0, -h * 0.5, w * 0.4, -h * 0.2);
        ctx.lineTo(w * 0.35, h * 0.2);
        ctx.quadraticCurveTo(0, h * 0.5, -w * 0.35, h * 0.2);
        ctx.closePath();
        ctx.fill();

        // eyes/crest by type
        if (e.type === 'boss') {
          ctx.fillStyle = '#fff';
          ctx.fillRect(-w * 0.1, -h * 0.05, w * 0.2, h * 0.1);
        } else if (e.type === 'fighter') {
          ctx.fillStyle = '#fff';
          ctx.fillRect(-w * 0.06, -h * 0.04, w * 0.12, h * 0.08);
        } else {
          ctx.fillStyle = '#fff';
          ctx.fillRect(-w * 0.04, -h * 0.03, w * 0.08, h * 0.06);
        }

        ctx.restore();
      }

      function drawStars(dt) {
        ctx.save();
        for (const s of G.stars) {
          s.y += s.speed * dt;
          if (s.y > CH + 2) {
            s.y = -2;
            s.x = rand(0, CW);
          }
          ctx.globalAlpha = s.alpha;
          ctx.fillStyle = '#fff';
          ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.r, s.r);
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      function drawHUD() {
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = '16px system-ui, sans-serif';
        ctx.textBaseline = 'top';
        ctx.fillText(`Score: ${G.score}`, 12, 12);
        ctx.fillText(`Hi: ${G.hi}`, 12, 32);
        ctx.fillText(`Wave: ${G.level}`, 12, 52);
        // Lives
        for (let i = 0; i < G.lives; i++) {
          drawShip(110 + i * 26, 24, 18, 14, '#9cf');
        }
        ctx.restore();
      }

      function drawBanner(text) {
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 28px system-ui, sans-serif';
        const m = ctx.measureText(text);
        ctx.fillText(text, (CW - m.width) * 0.5, CH * 0.08);
        ctx.restore();
      }

      function drawMessageCenter(lines) {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = 'bold 28px system-ui';
        const head = lines[0];
        let y = CH * 0.4;
        let m = ctx.measureText(head);
        ctx.fillText(head, (CW - m.width) / 2, y);
        ctx.font = '16px system-ui';
        y += 32;
        for (let i = 1; i < lines.length; i++) {
          const s = lines[i];
          m = ctx.measureText(s);
          ctx.fillText(s, (CW - m.width) / 2, y);
          y += 22;
        }
        ctx.restore();
      }

      function toast(text, dur = 1.3) {
        // quick top banner; reuse stageBannerT slot
        G.stageBannerT = dur;
        G.bannerText = text;
      }

      // --- Update & game logic ---
      function update(dt) {
        G.t += dt;

        // Player movement & shooting
        const p = G.player;
        if (G.mode === 'playing' && p && p.alive) {
          let dir = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
          p.x += dir * p.speed * dt;
          p.x = clamp(p.x, 18, CW - 18);
          if (keys.fire) playerShoot();
          if (p.cooldown > 0) p.cooldown -= dt;
          if (G.invincibleT > 0) {
            G.invincibleT -= dt;
            p.blinkT += dt;
          }
        }

        // Bullets (player)
        for (let i = G.bullets.length - 1; i >= 0; i--) {
          const b = G.bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.y < -20 || b.life <= 0) G.bullets.splice(i, 1);
        }

        // Enemy bullets
        for (let i = G.enemyBullets.length - 1; i >= 0; i--) {
          const b = G.enemyBullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.y > CH + 40 || b.life <= 0) G.enemyBullets.splice(i, 1);
        }

        // Enemies behavior
        const aliveEnemies = [];
        for (let e of G.enemies) {
          if (!e.alive) continue;

          if (e.state === 'enter') {
            // ease down into fy
            const dy = e.fy - e.y;
            e.y += clamp(dy, -200, 200) * dt * 1.5;
            const dx = e.fx - e.x;
            e.x += clamp(dx, -200, 200) * dt * 1.5;
            if (Math.abs(dy) < 2 && Math.abs(dx) < 2) {
              e.state = 'formation';
            }
          } else if (e.state === 'formation') {
            // bobbing
            e.bobPhase += dt * 1.5;
            e.x = e.fx + Math.sin(e.bobPhase + e.fy * 0.01) * 6;
            e.y = e.fy + Math.cos(e.bobPhase + e.fx * 0.01) * 3;
            // occasionally shoot (rare in formation)
            e.shootCD -= dt;
            if (e.shootCD < 0 && Math.random() < 0.02) {
              enemyShoot(e);
              e.shootCD = rand(2.0, 4.0);
            }
          } else if (e.state === 'dive') {
            e.diveT += dt;
            // swirl downward path with mild homing
            const s = e.speed;
            const swirl = Math.sin(e.diveT * (3.5 + Math.random() * 0.2)) * 120 * dt * e.diveDir;
            e.x += swirl + (p.x - e.x) * 0.06 * dt;
            e.y += s * dt;
            e.shootCD -= dt;
            if (e.shootCD < 0) {
              enemyShoot(e, true);
              e.shootCD = rand(0.7, 1.2);
            }
            if (e.y > CH - 80) {
              e.state = 'return';
              e.returnT = 0;
              e.startX = e.x;
              e.startY = e.y;
            }
          } else if (e.state === 'return') {
            e.returnT += dt * 0.8;
            const t = ease(e.returnT);
            e.x = e.startX + (e.fx - e.startX) * t;
            e.y = e.startY + (e.fy - e.startY) * t;
            if (t >= 1) {
              e.state = 'formation';
              e.bobPhase = rand(0, Math.PI * 2);
              e.shootCD = rand(1.0, 2.0);
            }
          }

          // death by leaving screen downward (rare)
          if (e.y > CH + 60) {
            e.alive = false;
          }
          if (e.alive) aliveEnemies.push(e);
        }

        // Schedule dives
        if (G.mode === 'playing' && G.t >= G.nextDiveAt && aliveEnemies.length > 0) {
          pickDivers(randi(1, 2));
          G.nextDiveAt = G.t + rand(2.0, 4.0) * (aliveEnemies.length > 15 ? 1 : 0.7);
        }

        // Collisions: bullets vs enemies
        for (let i = G.bullets.length - 1; i >= 0; i--) {
          const b = G.bullets[i];
          for (let j = 0; j < G.enemies.length; j++) {
            const e = G.enemies[j];
            if (!e.alive) continue;
            if (rectHit(b.x, b.y, b.r * 2, b.r * 2, e.x, e.y, e.w, e.h)) {
              e.hp -= 1;
              G.bullets.splice(i, 1);
              explode(e.x, e.y, e.color, 10);
              tone(600, 0.05, 'triangle', 0.03);
              if (e.hp <= 0) {
                e.alive = false;
                G.score += e.score;
              } else {
                // brief knockback
                e.x += (Math.random() < 0.5 ? -1 : 1) * 6;
              }
              break;
            }
          }
        }

        // Enemy bullets vs player
        if (p && p.alive) {
          for (let i = G.enemyBullets.length - 1; i >= 0; i--) {
            const b = G.enemyBullets[i];
            if (rectHit(b.x, b.y, b.r * 2, b.r * 2, p.x, p.y, p.w, p.h)) {
              if (G.invincibleT <= 0) {
                // player hit
                explode(p.x, p.y, '#9cf', 18);
                G.lives -= 1;
                tone(120, 0.12, 'sawtooth', 0.05);
                G.invincibleT = 2.5;
                p.blinkT = 0;
                if (G.lives <= 0) {
                  p.alive = false;
                  G.mode = 'gameover';
                  updateHiScore();
                }
              }
              G.enemyBullets.splice(i, 1);
            }
          }
        }

        // Enemies colliding with player
        if (p && p.alive && G.invincibleT <= 0) {
          for (let e of G.enemies) {
            if (!e.alive) continue;
            if (rectHit(p.x, p.y, p.w, p.h, e.x, e.y, e.w, e.h)) {
              explode(p.x, p.y, '#9cf', 24);
              G.lives -= 1;
              tone(110, 0.12, 'sawtooth', 0.05);
              G.invincibleT = 2.5;
              p.blinkT = 0;
              if (G.lives <= 0) {
                p.alive = false;
                G.mode = 'gameover';
                updateHiScore();
              }
              e.alive = false; // both suffer
            }
          }
        }

        // Particles
        for (let i = G.particles.length - 1; i >= 0; i--) {
          const pa = G.particles[i];
          pa.life -= dt;
          pa.x += pa.vx * dt;
          pa.y += pa.vy * dt;
          pa.vx *= (1 - 1.5 * dt);
          pa.vy *= (1 - 1.5 * dt);
          if (pa.life <= 0) G.particles.splice(i, 1);
        }

        // Wave cleared -> next wave
        const remaining = G.enemies.filter(e => e.alive).length;
        if (G.mode === 'playing' && remaining === 0) {
          G.level += 1;
          spawnWave(G.level);
          G.stageBannerT = 2.5;
        }

        // Stage banner timer
        if (G.stageBannerT > 0) {
          G.stageBannerT -= dt;
          if (G.stageBannerT <= 0) {
            G.bannerText = undefined;
          }
        }

        // Pause toggle
        if (keys.pause && G.mode === 'playing') {
          G.mode = 'paused';
          toast('Paused');
        }
      }

      function enemyShoot(e, aimed = false) {
        const aimX = aimed ? G.player.x : e.x + rand(-20, 20);
        const aimY = aimed ? G.player.y : e.y + 50;
        let dx = aimX - e.x;
        let dy = aimY - e.y;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len; dy /= len;
        const speed = 280 + (e.type === 'boss' ? 60 : 0);
        G.enemyBullets.push({
          x: e.x, y: e.y + e.h * 0.25,
          vx: dx * speed * 0.9,
          vy: Math.max(dy * speed, 120),
          r: 3,
          color: '#f88',
          life: 3.5
        });
        tone(320, 0.05, 'triangle', 0.03);
      }

      function updateHiScore() {
        if (G.score > G.hi) {
          G.hi = G.score;
          localStorage.setItem('galaga_hi', String(G.hi));
        }
      }

      // --- Main render ---
      function render() {
        ctx.clearRect(0, 0, CW, CH);

        // Background
        drawStars(G.dt);

        // Player
        const p = G.player;
        if (p) {
          const inv = G.invincibleT > 0 && (Math.floor(p.blinkT * 12) % 2 === 0);
          if (!inv) drawShip(p.x, p.y, p.w, p.h, '#9cf');
        }

        // Bullets
        for (const b of G.bullets) {
          ctx.fillStyle = b.color;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
          ctx.fill();
        }
        for (const b of G.enemyBullets) {
          ctx.fillStyle = b.color;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
          ctx.fill();
        }

        // Enemies
        for (const e of G.enemies) {
          if (!e.alive) continue;
          drawEnemy(e);
        }

        // Particles
        for (const pa of G.particles) {
          ctx.globalAlpha = Math.max(0, pa.life);
          ctx.fillStyle = pa.color;
          ctx.fillRect(pa.x, pa.y, pa.r, pa.r);
          ctx.globalAlpha = 1;
        }

        // HUD
        drawHUD();

        // Banners
        if (G.mode === 'menu') {
          drawMessageCenter([
            'Galaga-ish',
            'Move: Arrow Left/Right or A/D',
            'Fire: Space   Pause: P   Sound: M',
            'Start: Enter or Space',
            'Touch controls available on mobile'
          ]);
        } else if (G.mode === 'paused') {
          drawMessageCenter([
            'Paused',
            'Press P to resume'
          ]);
        } else if (G.mode === 'gameover') {
          drawMessageCenter([
            'Game Over',
            `Score: ${G.score}    Hi: ${G.hi}`,
            'Press Enter or Space to Restart'
          ]);
        }

        // Wave / Toast banner
        if (G.stageBannerT > 0) {
          drawBanner(G.bannerText || `Wave ${G.level}`);
        }
      }

      // --- Game loop ---
      function loop() {
        const t = now();
        G.dt = Math.min(0.033, Math.max(0.001, t - G.lastFrameAt));
        G.lastFrameAt = t;

        if (G.mode === 'playing') {
          update(G.dt);
        } else if (G.mode === 'paused') {
          // resume on P key release
          if (!keys.pause) {
            G.mode = 'playing';
            toast('Resumed');
          }
        }

        render();
        requestAnimationFrame(loop);
      }

      // Initialize
      resize();
      spawnStars();
      spawnPlayer();
      G.mode = 'menu';
      loop();

      // Start via canvas click/touch too
      canvas.addEventListener('click', () => {
        enableAudio();
        startIfMenu();
      }, { passive: true });

    })();
  </script>
</body>

</html>